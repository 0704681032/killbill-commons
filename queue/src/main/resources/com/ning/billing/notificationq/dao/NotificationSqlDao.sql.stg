group NotificationSqlDao;

CHECK_TENANT() ::= "search_key2 = :searchKey2"
AND_CHECK_TENANT() ::= "AND <CHECK_TENANT()>"



/*
  @SqlQuery
    public Long getLastInsertId();


    @SqlQuery
    public T getByRecordId(@Bind("recordId") Long id,
                           @Define("tableName") final String tableName);

    @SqlQuery
    public List<T> getReadyEntriesFromIds(@RecordIdCollectionBinder final List<Long> recordIds,
                                          @Define("tableName") final String tableName);

    @SqlQuery
    public List<T> getReadyEntries(@Bind("now") Date now,
                                   @Bind("owner") String owner,
                                   @Bind("max") int max,
                                   @Define("tableName") final String tableName);

    @SqlUpdate
    public int claimEntry(@Bind("recordId") Long id,
                          @Bind("now") Date now,
                          @Bind("owner") String owner,
                          @Bind("nextAvailable") Date nextAvailable,
                          @Define("tableName") final String tableName);

    @SqlUpdate
    public void removeEntry(@Bind("recordId") Long id,
                            @Define("tableName") final String tableName);

    @SqlUpdate
    public void insertEntry(@BindBean T evt,
                            @Define("tableName") final String tableName);

*/

getLastInsertId() ::= <<
    select LAST_INSERT_ID();
>>

getByRecordId(tableName) ::= <<
    select
      record_id
      , class_name
      , event_json
      , user_token
      , created_date
      , creating_owner
      , processing_owner
      , processing_available_date
      , processing_state
      , search_key1
      , search_key2
      , future_user_token
      , effective_date
      , queue_name
    from <tableName>
    where
    record_id = :recordId
    ;
>>



getReadyEntriesFromIds(tableName, record_ids) ::= <<
    select
      record_id
      , class_name
      , event_json
      , user_token
      , created_date
      , creating_owner
      , processing_owner
      , processing_available_date
      , processing_state
      , search_key1
      , search_key2
      , future_user_token
      , effective_date
      , queue_name
    from <tableName>
    where
    record_id in (<record_ids: {id | :id_<i0>}; separator="," >)
    order by
      record_id asc
    ;
>>


getReadyEntries(tableName) ::= <<
    select
      record_id
      , class_name
      , event_json
      , user_token
      , created_date
      , creating_owner
      , processing_owner
      , processing_available_date
      , processing_state
      , search_key1
      , search_key2
      , future_user_token
      , effective_date
      , queue_name
    from <tableName>
    where
      effective_date \<= :now
      and processing_state != 'PROCESSED'
      and processing_state != 'REMOVED'
      and (processing_owner IS NULL OR processing_available_date \<= :now)
    order by
      effective_date asc
      , created_date asc
      , record_id
    limit :max
    ;
>>

claimEntry(tableName) ::= <<
    update <tableName>
    set
      processing_owner = :owner
      , processing_available_date = :nextAvailable
      , processing_state = 'IN_PROCESSING'
    where
      record_id = :recordId
      and processing_state != 'PROCESSED'
      and processing_state != 'REMOVED'
      and (processing_owner IS NULL OR processing_available_date \<= :now)
    ;
>>



removeEntry(tableName)  ::= <<
  delete from <tableName>
    where
  record_id = :recordId
;
>>


insertEntry(tableName) ::= <<
    insert into <tableName> (
      class_name
      , event_json
      , user_token
      , created_date
      , creating_owner
      , processing_owner
      , processing_available_date
      , processing_state
      , search_key1
      , search_key2
      , future_user_token
      , effective_date
      , queue_name
    ) values (
        :className
      , :eventJson
      , :userToken
      , :createdDate
      , :creatingOwner
      , :processingOwner
      , :processingAvailableDate
      , :processingState
      , :searchKey1
      , :searchKey2
      , :futureUserToken
      , :effectiveDate
      , :queueName
    );
>>


removeNotificationsByKey() ::= <<
    update notifications
    set
      processing_state = 'REMOVED'
    where
      event_json = :eventJson
    ;
>>


getPendingCountNotifications() ::= <<
    select
      count(*)
    from notifications
    where
      effective_date \<= :now
      and processing_state = 'AVAILABLE'
    ;
>>

getFutureNotificationsForAccount() ::= <<
select
    record_id
  , class_name
  , event_json
  , user_token
  , future_user_token
  , created_date
  , creating_owner
  , effective_date
  , queue_name
  , processing_owner
  , processing_available_date
  , processing_state
  , search_key1
  , search_key2
from notifications
where queue_name = :queueName
and processing_state = 'AVAILABLE'
and search_key1 = :searchKey1
and effective_date >= :now
order by effective_date, record_id
;
>>

